{
    "min_heap": {
        "prefix": "min_heap",
        "body": [
            "priority_queue<$1, vector<$1>, greater<$1>>"
        ],
        "description": "heap"
    },
    "heap": {
        "prefix": "max_heap",
        "body": [
            "priority_queue<$1>"
        ],
        "description": "heap"
    },
    "unq": {
        "prefix": "unq",
        "body": [
            "$1.resize(distance($1.begin(), unique($1.begin(), $1.end())));"
        ],
        "description": "unique"
    },
    "size": {
        "prefix": "sz",
        "body": [
            "(int) $1.size()"
        ],
        "description": "heap"
    },
    "const int": {
        "prefix": "cint",
        "body": [
            "const int "
        ],
        "description": "const int"
    },
    "push_back": {
        "prefix": "ppb",
        "body": [
            "push_back($1)"
        ],
        "description": "push_back"
    },
    "lower_bound": {
        "prefix": "lb",
        "body": [
            "lower_bound($1)"
        ],
        "description": "lb"
    },
    "upper_bound": {
        "prefix": "ub",
        "body": [
            "upper_bound($1)"
        ],
        "description": "ub"
    },
    "all_select": {
        "prefix": "all",
        "body": [
            "$1.begin(), $1.end()"
        ],
        "description": "all"
    },
    "allr_select": {
        "prefix": "allr",
        "body": [
            "$1.rbegin(), $1.rend()"
        ],
        "description": "allr"
    },
    "sort": {
        "prefix": "sora",
        "body": [
            "sort($1.begin(), $1.end())"
        ],
        "description": "sort"
    },
    "rsort": {
        "prefix": "sorr",
        "body": [
            "sort($1.rbegin(), $1.rend())"
        ],
        "description": "rsort"
    },
    "new_line": {
        "prefix": "nl",
        "body": [
            "<< '\\n'"
        ],
        "description": "new_line"
    },
    "space": {
        "prefix": "spa",
        "body": [
            "<< ' '"
        ],
        "description": "space"
    },
    "first": {
        "prefix": "ff",
        "body": [
            "first"
        ],
        "description": "first"
    },
    "second": {
        "prefix": "sse",
        "body": [
            "second"
        ],
        "description": "second"
    },
    "forr": {
        "prefix": "fr",
        "body": [
            "for (auto& $1 : $2)"
        ],
        "description": "fori"
    },
    "rep": {
        "prefix": "rep",
        "body": [
            "for (int $1 = $2; $1 < $3; $1++) $0"
        ],
        "description": "for loop"
    },
    "repr": {
        "prefix": "repr",
        "body": [
            "for (int $1 = $2; $1 >= $3; $1--) $0"
        ],
        "description": "for loop"
    },
    "debug": {
        "prefix": "dbg",
        "body": [
            "debug($0)"
        ],
        "description": "for"
    },
    "vi": {
        "prefix": "vi",
        "body": [
            "vector<int> "
        ],
        "description": "vector"
    },
    "pii": {
        "prefix": "pii",
        "body": [
            "pair<int, int> "
        ],
        "description": "pair"
    },
    "vpi": {
        "prefix": "vpi",
        "body": [
            "vector<pair<int, int>> "
        ],
        "description": "vector"
    },
    "pll": {
        "prefix": "pll",
        "body": [
            "pair<ll, ll> "
        ],
        "description": "pair"
    },
    "vpl": {
        "prefix": "vpl",
        "body": [
            "vector<pair<ll, ll>> "
        ],
        "description": "vector"
    },
    "vvi": {
        "prefix": "vvi",
        "body": [
            "vector<vector<int>> "
        ],
        "description": "vector"
    },
    "vvvi": {
        "prefix": "vvvi",
        "body": [
            "vector<vector<vector<int>>> "
        ],
        "description": "vector"
    },
    "vl": {
        "prefix": "vl",
        "body": [
            "vector<ll> "
        ],
        "description": "vector"
    },
    "vs": {
        "prefix": "vs",
        "body": [
            "vector<string> "
        ],
        "description": "vector"
    },
    "vvl": {
        "prefix": "vvl",
        "body": [
            "vector<vector<ll>> "
        ],
        "description": "vector"
    },
    "vvvl": {
        "prefix": "vvvl",
        "body": [
            "vector<vector<vector<<ll>>> "
        ],
        "description": "vector"
    },
    "vld": {
        "prefix": "vld",
        "body": [
            "vector<ld> "
        ],
        "description": "vector"
    },
    "s_b": {
        "prefix": "setbits",
        "body": [
            "__builtin_popcountll($1)"
        ],
        "description": "set bits"
    },
    "lambda-auto": {
        "prefix": "lma",
        "body": [
            "auto $1 = [&] ($2) -> $3 {",
            "    $0",
            "};"
        ],
        "description": "lambda-auto"
    },
    "recursive lambda": {
        "prefix": "lmr",
        "body": [
            "auto $1 = [&] (auto &&self, $2) -> $3 {",
            "    $0",
            "};"
        ],
        "description": "recursive lambda"
    },
    "tree helper ": {
        "prefix": "tree_helper",
        "body": [
            "struct Tree {",
            "    int n, LOG, timer;",
            "    vector<int> tin, tout, depth, flat, par;",
            "    vector<vector<int>> adj, up;",
            "",
            "    Tree(int n) {",
            "        this->n = n;",
            "        tin.resize(n);",
            "        tout.resize(n);",
            "        depth.resize(n);",
            "        par.resize(n);",
            "        flat.resize(2 * n);",
            "        timer = 0;",
            "        adj.resize(n);",
            "        LOG = ceil(log2(n));",
            "        up.assign(n, vector<int>(LOG + 1));",
            "    }",
            "",
            "    void add_edge(int a, int b) {",
            "        assert(0 <= a and a < n);",
            "        assert(0 <= b and b < n);",
            "        adj[a].emplace_back(b);",
            "        adj[b].emplace_back(a);",
            "    }",
            "",
            "    void build(int root) {",
            "        depth[root] = 0;",
            "        dfs(root, -1);",
            "    }",
            "",
            "    void dfs(int v, int p) {",
            "        par[v] = p;",
            "        flat[timer] = v;",
            "        tin[v] = timer++;",
            "        if (p != -1) depth[v] = depth[p] + 1;",
            "        up[v][0] = (p == -1 ? v : p);",
            "        for (int i = 1; i <= LOG; ++i) up[v][i] = up[up[v][i - 1]][i - 1];",
            "        for (auto& u : adj[v])",
            "            if (u != p) dfs(u, v);",
            "        flat[timer] = v;",
            "        tout[v] = timer++;",
            "    }",
            "",
            "    bool is_ancestor(int u, int v) { return tin[u] <= tin[v] && tout[u] >= tout[v]; }",
            "",
            "    int lca(int u, int v) {",
            "        if (is_ancestor(u, v)) return u;",
            "        if (is_ancestor(v, u)) return v;",
            "        for (int i = LOG; i >= 0; i--)",
            "            if (!is_ancestor(up[u][i], v)) u = up[u][i];",
            "        return up[u][0];",
            "    }",
            "",
            "    int dist(int u, int v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }",
            "",
            "    int kth_node(int u, int v, int k) {",
            "        int l = lca(u, v), d = depth[v] + depth[u] - 2 * depth[l];",
            "        assert(0 <= k and k <= d);",
            "        int dul = depth[u] - depth[l];",
            "        if (k <= dul) {",
            "            int ans = u;",
            "            for (int i = 0; i <= LOG; i++)",
            "                if (k & (1 << i)) ans = up[ans][i];",
            "            return ans;",
            "        }",
            "        int dvl = depth[v] - depth[l], dd = dvl - (k - dul), ans = v;",
            "        for (int i = 0; i <= LOG; i++)",
            "            if (dd & (1 << i)) ans = up[ans][i];",
            "        return ans;",
            "    }",
            "",
            "    int kth_ancestor(int u, int k, int root = 0) { return kth_node(u, root, k); }",
            "};"
        ],
        "description": "tree helper "
    },
    "diophantine": {
        "prefix": "diophantine",
        "body": [
            "long long gcd(long long a, long long b, long long &x, long long &y)",
            "{",
            "    if (b == 0)",
            "    {",
            "        x = 1;",
            "        y = 0;",
            "        return a;",
            "    }",
            "    long long x1, y1;",
            "    long long d = gcd(b, a % b, x1, y1);",
            "    x = y1;",
            "    y = x1 - y1 * (a / b);",
            "    return d;",
            "}",
            "",
            "bool find_any_solution(long long a, long long b, long long c, long long &x0, long long &y0, long long &g)",
            "{",
            "    g = gcd(abs(a), abs(b), x0, y0);",
            "    if (c % g)",
            "    {",
            "        return false;",
            "    }",
            "",
            "    x0 *= c / g;",
            "    y0 *= c / g;",
            "    if (a < 0)",
            "        x0 = -x0;",
            "    if (b < 0)",
            "        y0 = -y0;",
            "    return true;",
            "}",
            "",
            "void shift_solution(long long &x, long long &y, long long a, long long b, long long cnt)",
            "{",
            "    x += cnt * b;",
            "    y -= cnt * a;",
            "}",
            "",
            "long long find_all_solutions(long long a, long long b, long long c, long long minx, long long maxx, long long miny, long long maxy)",
            "{",
            "    long long x, y, g;",
            "    if (!find_any_solution(a, b, c, x, y, g))",
            "        return 0;",
            "    a /= g;",
            "    b /= g;",
            "",
            "    long long sign_a = a > 0 ? +1 : -1;",
            "    long long sign_b = b > 0 ? +1 : -1;",
            "",
            "    shift_solution(x, y, a, b, (minx - x) / b);",
            "    if (x < minx)",
            "        shift_solution(x, y, a, b, sign_b);",
            "    if (x > maxx)",
            "        return 0;",
            "    long long lx1 = x;",
            "",
            "    shift_solution(x, y, a, b, (maxx - x) / b);",
            "    if (x > maxx)",
            "        shift_solution(x, y, a, b, -sign_b);",
            "    long long rx1 = x;",
            "",
            "    shift_solution(x, y, a, b, -(miny - y) / a);",
            "    if (y < miny)",
            "        shift_solution(x, y, a, b, -sign_a);",
            "    if (y > maxy)",
            "        return 0;",
            "    long long lx2 = x;",
            "",
            "    shift_solution(x, y, a, b, -(maxy - y) / a);",
            "    if (y > maxy)",
            "        shift_solution(x, y, a, b, sign_a);",
            "    long long rx2 = x;",
            "",
            "    if (lx2 > rx2)",
            "        swap(lx2, rx2);",
            "    long long lx = max(lx1, lx2);",
            "    long long rx = min(rx1, rx2);",
            "",
            "    if (lx > rx)",
            "        return 0;",
            "    return (rx - lx) / abs(b) + 1;",
            "}"
        ],
        "description": "diophantine"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "struct DSU {",
            "    vector<int> siz, par;",
            "    int comps;",
            "",
            "    DSU(int n) {",
            "        par.resize(n + 1);",
            "        siz.resize(n + 1, 1);",
            "        iota(par.begin(), par.end(), 0);",
            "        comps = n;",
            "    }",
            "",
            "    int find(int i) {",
            "        if (par[i] == i) return i;",
            "        return par[i] = find(par[i]);",
            "    }",
            "",
            "    void unite(int u, int v) {",
            "        if (same(u, v)) return;",
            "        if (set_size(u) < set_size(v)) swap(u, v);",
            "        u = find(u), v = find(v), comps--;",
            "        par[v] = u, siz[u] += siz[v];",
            "    }",
            "    ",
            "    int set_size(int i) { return siz[find(i)]; }",
            "",
            "    bool same(int u, int v) { return find(u) == find(v); }",
            "};"
        ],
        "description": "DSU"
    },
    "string hashing": {
        "prefix": "hashing",
        "body": [
            "const int N = 5e5 + 5;",
            "",
            "long long gcd(long long a, long long b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}",
            "long long lcm(long long a, long long b) { return a * b / gcd(a, b); }",
            "long long exp(long long a, long long b, long long mod) {a %= mod; long long res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}",
            "long long inv(long long a, long long b) {return exp(a, b - 2, b);}",
            "long long add(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
            "long long mul(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
            "long long sub(long long a, long long b, long long m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
            "long long dvd(long long a, long long b, long long m) {a = a % m; b = b % m; return (mul(a, inv(b, m), m) + m) % m;}",
            "",
            "mt19937 gen(chrono::steady_clock::now().time_since_epoch().count());",
            "const long long base = gen() % N + 32;",
            "",
            "struct Hashing",
            "{",
            "    string s;",
            "    int n;",
            "    int primes;",
            "    vector<long long> hash_primes = {1000000009, 100000007};",
            "    vector<vector<long long>> hash_values;",
            "    vector<vector<long long>> power_of_base;",
            "    vector<vector<long long>> inverse_power_of_base;",
            "",
            "    Hashing(string a)",
            "    {",
            "        primes = hash_primes.size();",
            "        hash_values.resize(primes);",
            "        power_of_base.resize(primes);",
            "        inverse_power_of_base.resize(primes);",
            "        s = a;",
            "        n = s.length();",
            "        for (int i = 0; i < (int) hash_primes.size(); i++)",
            "        {",
            "            power_of_base[i].resize(n + 1);",
            "            inverse_power_of_base[i].resize(n + 1);",
            "            power_of_base[i][0] = 1;",
            "            for (int j = 1; j <= n; j++)",
            "                power_of_base[i][j] = (base * power_of_base[i][j - 1]) % hash_primes[i];",
            "            inverse_power_of_base[i][n] = inv(power_of_base[i][n], hash_primes[i]);",
            "            for (int j = n - 1; j >= 0; j--)",
            "                inverse_power_of_base[i][j] = mul(inverse_power_of_base[i][j + 1], base, hash_primes[i]);",
            "        }",
            "        for (int i = 0; i < (int) hash_primes.size(); i++)",
            "        {",
            "            hash_values[i].resize(n);",
            "            for (int j = 0; j < n; j++)",
            "            {",
            "                hash_values[i][j] = ((s[j] - 'a' + 1LL) * power_of_base[i][j]) % hash_primes[i];",
            "                hash_values[i][j] = (hash_values[i][j] + (j > 0 ? hash_values[i][j - 1] : 0LL)) % hash_primes[i];",
            "            }",
            "        }",
            "    }",
            "",
            "    vector<long long> substring_hash(int l, int r)",
            "    {",
            "        vector<long long> hash(primes);",
            "        for (int i = 0; i < primes; i++)",
            "        {",
            "            long long val1 = hash_values[i][r];",
            "            long long val2 = l > 0 ? hash_values[i][l - 1] : 0LL;",
            "            hash[i] = mul(sub(val1, val2, hash_primes[i]), inverse_power_of_base[i][l], hash_primes[i]);",
            "        }",
            "        return hash;",
            "    }",
            "};"
        ],
        "description": "string hashing"
    },
    "custom_hash": {
        "prefix": "custom_hash",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};"
        ],
        "description": "custom_hash"
    },
    "lazy segment tree": {
        "prefix": "lazy_segment_tree",
        "body": [
            "template <class T, class U>",
            "struct SegmentTree {",
            "    vector<T> st;",
            "    vector<U> lazy;",
            "    long long n;",
            "    T identity_element;",
            "    U identity_update;",
            "",
            "    SegmentTree(long long n, T identity_element, U identity_update) {",
            "        this->n = n;",
            "        this->identity_element = identity_element;",
            "        this->identity_update = identity_update;",
            "        st.assign(4 * n, identity_element);",
            "        lazy.assign(4 * n, identity_update);",
            "    }",
            "",
            "    T combine(T l, T r) {",
            "        T ans = (l + r);",
            "        return ans;",
            "    }",
            "",
            "    void build_util(long long v, long long tl, long long tr, vector<T>& a) {",
            "        if (tl == tr) {",
            "            st[v] = a[tl];",
            "            return;",
            "        }",
            "        long long tm = (tl + tr) >> 1;",
            "        build_util(2 * v + 1, tl, tm, a);",
            "        build_util(2 * v + 2, tm + 1, tr, a);",
            "        st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
            "    }",
            "",
            "    T apply(T curr, U upd, long long tl, long long tr) {",
            "        T ans = upd;",
            "        return ans;",
            "    }",
            "",
            "    U combine_update(U old_upd, U new_upd, long long tl, long long tr) {",
            "        U ans = old_upd;",
            "        ans = new_upd;",
            "        return ans;",
            "    }",
            "",
            "    void push_down(long long v, long long tl, long long tr) {",
            "        if (lazy[v] == identity_update) return;",
            "        st[v] = apply(st[v], lazy[v], tl, tr);",
            "        if (2 * v + 2 < 4 * n) {",
            "            long long tm = (tl + tr) >> 1;",
            "            lazy[2 * v + 1] = combine_update(lazy[2 * v + 1], lazy[v], tl, tm);",
            "            lazy[2 * v + 2] = combine_update(lazy[2 * v + 2], lazy[v], tm + 1, tr);",
            "        }",
            "        lazy[v] = identity_update;",
            "    }",
            "",
            "    T query_util(long long v, long long tl, long long tr, long long l, long long r) {",
            "        push_down(v, tl, tr);",
            "        if (l > r or tr < l or tl > r) return identity_element;",
            "        if (l <= tl and r >= tr) return st[v];",
            "        long long tm = (tl + tr) >> 1;",
            "        return combine(query_util(2 * v + 1, tl, tm, l, r), query_util(2 * v + 2, tm + 1, tr, l, r));",
            "    }",
            "",
            "    void update_util(long long v, long long tl, long long tr, long long l, long long r, U upd) {",
            "        push_down(v, tl, tr);",
            "        if (tr < l or tl > r) return;",
            "        if (tl >= l and tr <= r) {",
            "            lazy[v] = combine_update(lazy[v], upd, tl, tr);",
            "            push_down(v, tl, tr);",
            "        } else {",
            "            long long tm = (tl + tr) >> 1;",
            "            update_util(2 * v + 1, tl, tm, l, r, upd);",
            "            update_util(2 * v + 2, tm + 1, tr, l, r, upd);",
            "            st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
            "        }",
            "    }",
            "",
            "    void build(vector<T> a) {",
            "        assert(a.size() == n);",
            "        build_util(0, 0, n - 1, a);",
            "    }",
            "",
            "    T query(long long l, long long r) {",
            "        return query_util(0, 0, n - 1, l, r);",
            "    }",
            "",
            "    void update(long long l, long long r, U upd) {",
            "        update_util(0, 0, n - 1, l, r, upd);",
            "    }",
            "};"
        ],
        "description": "lazy segment tree"
    },
    "merge sort tree": {
        "prefix": "merge_sort_tree",
        "body": [
            "template <class T>",
            "struct Merge {",
            "    vector<vector<T>> st;",
            "    int n;",
            "",
            "    Merge(int n) : n(n) { st.resize(4 * n + 4); }",
            "",
            "    void build(vector<T> &v) {",
            "        assert(v.size() == n);",
            "        buildUtil(1, 1, n, v);",
            "    }",
            "",
            "    long long query(int l, int r, T q) { return queryUtil(1, 1, n, l + 1, r + 1, q); }",
            "",
            "    void buildUtil(int si, int ss, int se, vector<T> &v) {",
            "        if (se == ss) {",
            "            st[si].push_back(v[ss - 1]);",
            "        } else {",
            "            int sm = (ss + se) >> 1;",
            "            buildUtil(2 * si, ss, sm, v);",
            "            buildUtil(2 * si + 1, sm + 1, se, v);",
            "            merge(st[2 * si].begin(), st[2 * si].end(), st[2 * si + 1].begin(), st[2 * si + 1].end(), back_inserter(st[si]));",
            "        }",
            "    }",
            "",
            "    long long queryUtil(int si, int ss, int se, int l, int r, T q) {",
            "        if (ss > r || se < l) return 0;",
            "        if (ss >= l && se <= r) return lower_bound(st[si].begin(), st[si].end(), q) - st[si].begin();",
            "        int sm = (ss + se) >> 1;",
            "        return queryUtil(2 * si, ss, sm, l, r, q) + queryUtil(2 * si + 1, sm + 1, se, l, r, q);",
            "    }",
            "};"
        ],
        "description": "merge sort tree"
    },
    "modular arithmetic": {
        "prefix": "modular_arithmetic",
        "body": [
            "const int M = 998244353;",
            "long long fact[1000005], ifact[1000005];",
            "",
            "long long gcd(long long a, long long b) {if (b > a) {return gcd(b, a);} if (b == 0) {return a;} return gcd(b, a % b);}",
            "long long lcm(long long a, long long b) { return a * b / gcd(a, b); }",
            "long long exp(long long a, long long b, long long mod = M) {res %= mod; long long res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}",
            "long long inv(long long a, long long b = M) {return exp(a, b - 2, b);}",
            "long long nCr(long long n, long long r, long long m = M) {long long val1 = fact[n]; long long val2 = ifact[n - r]; long long val3 = ifact[r]; return (((val1 * val2) % m) * val3) % m;}",
            "long long add(long long a, long long b, long long m = M) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}",
            "long long mul(long long a, long long b, long long m = M) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}",
            "long long sub(long long a, long long b, long long m = M) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}",
            "long long dvd(long long a, long long b, long long m = M) {a = a % m; b = b % m; return (mul(a, inv(b, m), m) + m) % m;}",
            ""
        ],
        "description": "modular arithmetic"
    },
    "modular struct": {
        "prefix": "mint",
        "body": [
            "const int M = 998244353;",
            "",
            "template <unsigned int mod = M>",
            "struct mint {",
            "    unsigned int x;",
            "    mint() : x(0) {}",
            "    mint(long long _x) {",
            "        _x %= mod;",
            "        if (_x < 0) _x += mod;",
            "        x = _x;",
            "    }",
            "    mint &operator+=(const mint &a) {",
            "        x += a.x;",
            "        if (x >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "    mint &operator-=(const mint &a) {",
            "        x += mod - a.x;",
            "        if (x >= mod) x -= mod;",
            "        return *this;",
            "    }",
            "",
            "    mint &operator*=(const mint &a) {",
            "        x = (long long)x * a.x % mod;",
            "        return *this;",
            "    }",
            "    mint pow(long long pw) const {",
            "        mint res = 1;",
            "        mint cur = *this;",
            "        while (pw) {",
            "            if (pw & 1) res *= cur;",
            "            cur *= cur;",
            "            pw >>= 1;",
            "        }",
            "        return res;",
            "    }",
            "    mint inv() const {",
            "        assert(x != 0);",
            "        unsigned int t = x;",
            "        unsigned int res = 1;",
            "        while (t != 1) {",
            "            unsigned int z = mod / t;",
            "            res = (long long)res * (mod - z) % mod;",
            "            t = mod - t * z;",
            "        }",
            "        return res;",
            "    }",
            "    mint &operator/=(const mint &a) { return *this *= a.inv(); }",
            "    mint operator+(const mint &a) const { return mint(*this) += a; }",
            "    mint operator-(const mint &a) const { return mint(*this) -= a; }",
            "    mint operator*(const mint &a) const { return mint(*this) *= a; }",
            "    mint operator/(const mint &a) const { return mint(*this) /= a; }",
            "    bool operator==(const mint &a) const { return x == a.x; }",
            "    bool operator!=(const mint &a) const { return x != a.x; }",
            "    bool operator<(const mint &a) const { return x < a.x; }",
            "    friend ostream &operator<<(std::ostream &os, mint const &a) { return os << a.x; }",
            "    friend istream &operator>>(istream &is, mint &a) {",
            "        long long _x;",
            "        is >> _x;",
            "        a = mint(_x);",
            "        return is;",
            "    }",
            "};",
            "",
            "template <unsigned int mod = M>",
            "struct Factorials {",
            "    using Mint = mint<mod>;",
            "    vector<Mint> f, fi;",
            "    Factorials() : f(), fi() {}",
            "    Factorials(int n) {",
            "        n += 8;",
            "        f = vector<Mint>(n);",
            "        fi = vector<Mint>(n);",
            "        f[0] = 1;",
            "        for (int i = 1; i < n; i++) f[i] = f[i - 1] * i;",
            "        fi[n - 1] = f[n - 1].inv();",
            "        for (int i = n - 1; i > 0; i--) fi[i - 1] = fi[i] * i;",
            "    }",
            "    Mint C(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        return f[n] * fi[k] * fi[n - k];",
            "    }",
            "    Mint P(int n, int k) {",
            "        if (k < 0 || k > n) return 0;",
            "        return f[n] * fi[n - k];",
            "    }",
            "};",
            "",
            "using Z = mint<>"
        ],
        "description": "modular struct"
    },
    "mos_algo": {
        "prefix": "mos_algo",
        "body": [
            "void remove(int idx) {}",
            "",
            "void add(int idx) {}",
            "",
            "long long get_answer() {}",
            "",
            "int block_size;",
            "",
            "struct Query",
            "{",
            "    int l, r, idx;",
            "    bool operator<(Query other) const",
            "    {",
            "        return make_pair(l / block_size, r) <",
            "               make_pair(other.l / block_size, other.r);",
            "    }",
            "};",
            "",
            "vector<long long> mo_s_algorithm(vector<Query> queries)",
            "{",
            "    vector<long long> answers(queries.size());",
            "    sort(queries.begin(), queries.end());",
            "",
            "    int cur_l = 0;",
            "    int cur_r = -1;",
            "    for (Query q : queries)",
            "    {",
            "        while (cur_l > q.l)",
            "        {",
            "            cur_l--;",
            "            add(cur_l);",
            "        }",
            "        while (cur_r < q.r)",
            "        {",
            "            cur_r++;",
            "            add(cur_r);",
            "        }",
            "        while (cur_l < q.l)",
            "        {",
            "            remove(cur_l);",
            "            cur_l++;",
            "        }",
            "        while (cur_r > q.r)",
            "        {",
            "            remove(cur_r);",
            "            cur_r--;",
            "        }",
            "        answers[q.idx] = get_answer();",
            "    }",
            "    return answers;",
            "}"
        ],
        "description": "mos_algo"
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "using namespace __gnu_pbds;",
            "",
            "template <class T>",
            "using indexed_set = tree<T, null_type, less_equal<T>, rb_tree_tag,",
            "tree_order_statistics_node_update>;"
        ],
        "description": "pbds"
    },
    "linear sieve": {
        "prefix": "sieve",
        "body": [
            "const int N = 1'000'000 + 5;",
            "",
            "int spf[N], is_prime[N];",
            "vector<int> primes;",
            "",
            "void sieve() {",
            "    for (int i = 2; i < N; i++) {",
            "        if (not spf[i]) {",
            "            is_prime[i] = 1;",
            "            spf[i] = i;",
            "            primes.push_back(i);",
            "        }",
            "        for (int j = 0; i * primes[j] < N; j++) {",
            "            spf[i * primes[j]] = primes[j];",
            "            if (primes[j] == spf[i]) break;",
            "        }",
            "    }",
            "}"
        ],
        "description": "linear sieve"
    },
    "sparse table": {
        "prefix": "sparse_table",
        "body": [
            "template <class T>",
            "struct SparseTable {",
            "    vector<vector<T>> table;",
            "    int n;",
            "    int K;",
            "",
            "    T combine(T l, T r) { return min(l, r); }",
            "",
            "    SparseTable(const vector<T> &v) {",
            "        n = (int)v.size();",
            "        K = log2(n) + 1;",
            "        table.assign(n, vector<T>(K, 0));",
            "",
            "        for (int i = 0; i < n; ++i) table[i][0] = v[i];",
            "",
            "        for (int j = 1; j < K; ++j) {",
            "            for (int i = 0; i + (1 << j) <= n; ++i) {",
            "                table[i][j] = combine(table[i][j - 1], table[i + (1 << (j - 1))][j - 1]);",
            "            }",
            "        }",
            "    }",
            "",
            "    T query(int l, int r) {",
            "        const int width = r - l + 1;",
            "        const int k = log2(width);",
            "        T res = combine(table[r - (1 << k) + 1][k], table[l][k]);",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "sparse table"
    },
    "trie_bits": {
        "prefix": "trie_bits",
        "body": [
            "class Node",
            "{",
            "",
            "    Node *links[2];",
            "",
            "public:",
            "    int frq[2];",
            "    Node()",
            "    {",
            "        links[0] = links[1] = nullptr;",
            "        frq[0] = frq[1] = 0;",
            "    }",
            "",
            "    bool containsLink(int b)",
            "    {",
            "        return links[b];",
            "    }",
            "",
            "    void createLink(int b)",
            "    {",
            "        links[b] = new Node();",
            "    }",
            "",
            "    Node *goToLink(int b)",
            "    {",
            "        return links[b];",
            "    }",
            "};",
            "",
            "class Trie",
            "{",
            "",
            "    Node *root;",
            "",
            "public:",
            "    Trie()",
            "    {",
            "        root = new Node();",
            "    }",
            "",
            "    void insert(int x)",
            "    {",
            "        Node *t = root;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int b = (x >> i) & 1;",
            "            if (!t->containsLink(b))",
            "                t->createLink(b);",
            "            t->frq[b]++;",
            "            t = t->goToLink(b);",
            "        }",
            "    }",
            "",
            "    void remove(int x)",
            "    {",
            "        Node *t = root;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int b = (x >> i) & 1;",
            "            t->frq[b]--;",
            "            t = t->goToLink(b);",
            "        }",
            "    }",
            "",
            "    int getMaximumXOR(int y)",
            "    {",
            "        Node *t = root;",
            "        int res = 0;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int by = (y >> i) & 1, w = 1 - by;",
            "            if (t->frq[w])",
            "            {",
            "                res = res | (1 << i);",
            "                t = t->goToLink(w);",
            "            }",
            "            else",
            "            {",
            "                t = t->goToLink(by);",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "trie_bits"
    },
    "trie_string": {
        "prefix": "trie_string",
        "body": [
            "class Node",
            "{",
            "",
            "    Node *links[26];",
            "    bool flag;",
            "",
            "public:",
            "    Node()",
            "    {",
            "        for (int i = 0; i < 26; i++)",
            "            links[i] = NULL;",
            "        flag = false;",
            "    }",
            "",
            "    bool containsLink(char c)",
            "    {",
            "        return links[c - 'a'] != NULL;",
            "    }",
            "",
            "    void newLink(char c)",
            "    {",
            "        links[c - 'a'] = new Node();",
            "    }",
            "",
            "    Node *goToLink(char c)",
            "    {",
            "        return links[c - 'a'];",
            "    }",
            "",
            "    void setEnd()",
            "    {",
            "        flag = true;",
            "    }",
            "",
            "    bool isEnd()",
            "    {",
            "        return flag;",
            "    }",
            "};",
            "",
            "class Trie",
            "{",
            "",
            "    Node *root;",
            "",
            "public:",
            "    Trie()",
            "    {",
            "        root = new Node();",
            "    }",
            "",
            "    void insert(string word)",
            "    {",
            "        Node *t = root;",
            "        for (char c : word)",
            "        {",
            "            if (!(t->containsLink(c)))",
            "                t->newLink(c);",
            "            t = t->goToLink(c);",
            "        }",
            "        t->setEnd();",
            "    }",
            "",
            "    bool search(string word)",
            "    {",
            "        Node *t = root;",
            "        for (char c : word)",
            "        {",
            "            if (!(t->containsLink(c)))",
            "                return false;",
            "            t = t->goToLink(c);",
            "        }",
            "        return t->isEnd();",
            "    }",
            "  ",
            "    bool startsWith(string prefix)",
            "    {",
            "        Node *t = root;",
            "        for (char c : prefix)",
            "        {",
            "            if (!(t->containsLink(c)))",
            "                return false;",
            "            t = t->goToLink(c);",
            "        }",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "trie_string"
    },
    "z_algo": {
        "prefix": "z_algo",
        "body": [
            "vector<int> Z(string s) {",
            "    int n = s.size(), l = 0, r = 0;",
            "    vector<int> z(n);",
            "    for(int i = 1; i < n; i++) {",
            "        if(i < r) {",
            "            z[i] = min(r - i, z[i - l]);",
            "        }",
            "        while(i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
            "            z[i]++;",
            "        }",
            "        if(i + z[i] > r) {",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "z_algo"
    },
    "boiler plate ": {
        "prefix": "boilerplate",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifndef ONLINE_JUDGE",
            "#include \"debugger\\debug.h\"",
            "#else",
            "#define debug(...) 8",
            "#endif",
            "#define int long long",
            "",
            "void solve() {$0}",
            "",
            "signed main() {",
            "    cin.tie(0)->sync_with_stdio(0);",
            "    int T = 1;",
            "    cin >> T;",
            "    while (T--) solve();",
            "}"
        ],
        "description": "boiler plate "
    }
}